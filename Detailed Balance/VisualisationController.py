#!/usr/bin/env python
# coding: utf-8

import matplotlib.pyplot as plt
import numpy as np
import pints
from matplotlib.animation import FuncAnimation
import seaborn as sb
from datetime import datetime

class MCMCVisualiser(object):
    def __init__(self, log_pdf, chains, x0, sigma0=None, method=None):
        self.x0 = np.array(x0)
        # Store function
        if not isinstance(log_pdf, pints.LogPDF):
            raise ValueError('Given function must extend pints.LogPDF')
        self._log_pdf = log_pdf

        # Get number of parameters
        self._n_parameters = self._log_pdf.n_parameters()

        # Check number of chains
        self._n_chains = int(chains)
        if self._n_chains < 1:
            raise ValueError('Number of chains must be at least 1.')

        # Check initial position(s): Most checking is done by samplers!
        if len(x0) != chains:
            raise ValueError(
                'Number of initial positions must be equal to number of'
                ' chains.')
        if not all([len(x) == self._n_parameters for x in x0]):
            raise ValueError(
                'All initial positions must have the same dimension as the'
                ' given LogPDF.')

        # Don't check initial standard deviation: done by samplers!

        # Set default method
        if method is None:
            method = pints.HaarioBardenetACMC
        else:
            try:
                ok = issubclass(method, pints.MCMCSampler)
            except TypeError:   # Not a class
                ok = False
            if not ok:
                raise ValueError('Given method must extend pints.MCMCSampler.')

        # Using single chain samplers?
        self._single_chain = issubclass(method, pints.SingleChainMCMC)

        # Create sampler(s)
        if self._single_chain:
            # Using n individual samplers (Note that it is possible to have
            # _single_chain=True and _n_samplers=1)
            self._n_samplers = self._n_chains
            self._samplers = [method(x, sigma0) for x in x0]
        else:
            # Using a single sampler that samples multiple chains
            self._n_samplers = 1
            self._samplers = [method(self._n_chains, x0, sigma0)]

        # Check if sensitivities are required
        self._needs_sensitivities = self._samplers[0].needs_sensitivities()

        # Initial phase (needed for e.g. adaptive covariance)
        self._initial_phase_iterations = None
        self._needs_initial_phase = self._samplers[0].needs_initial_phase()
        if self._needs_initial_phase:
            self.set_initial_phase_iterations()

        # Storing chains and evaluations in memory
        self._chains_in_memory = True
        self._evaluations_in_memory = False
        self._samples = None
        self._evaluations = None
        self._time = None

        # Parallelisation
        self._parallel = False
        self._n_workers = 1
        self.set_parallel()

        #
        # Stopping criteria
        #

        # Maximum iterations
        self._max_iterations = None
        self.set_max_iterations()
    
    def flatten(self,plots):
            plist = []
            for i in range(len(plots)):
                for j in range(len(plots[i])):
                    plist.append(plots[i][j])
            return plist

    def chains(self):
        """
        Returns the chains generated by :meth:`run()`.

        The returned array has shape ``(n_chains, n_iterations,
        n_parameters)``.

        If the controller has not run yet, or if chain storage to memory is
        disabled, this method will return ``None``.
        """
        # Note: Not copying this, for efficiency. At this point we're done with
        # the chains, so nothing will go wrong if the user messes the array up.
        return self._samples

    def initial_phase_iterations(self):
        """
        For methods that require an initial phase (e.g. an adaptation-free
        phase for the adaptive covariance MCMC method), this returns the number
        of iterations that the initial phase will take.

        For methods that do not require an initial phase, a
        ``NotImplementedError`` is raised.
        """
        return self._initial_phase_iterations

    def log_pdfs(self):
        """
        Returns the :class:`LogPDF` evaluations generated by :meth:`run()`.

        If a :class:`LogPosterior` was used, the returned array will have shape
        ``(n_chains, n_iterations, 3)``, and for each sample the LogPDF,
        LogLikelihood, and LogPrior will be stored.
        For all other cases, only the full LogPDF evaluations are returned, in
        an array of shape ``(n_chains, n_iterations)``.

        If the controller has not run yet, or if storage of evaluations to
        memory is disabled (default), this method will return ``None``.
        """
        # Note: Not copying this, for efficiency. At this point we're done with
        # the chains, so nothing will go wrong if the user messes the array up.
        return self._evaluations

    def max_iterations(self):
        """
        Returns the maximum iterations if this stopping criterion is set, or
        ``None`` if it is not. See :meth:`set_max_iterations()`.
        """
        return self._max_iterations

    def method_needs_initial_phase(self):
        """
        Returns true if this sampler has been created with a method that has
        an initial phase (see :meth:`MCMCSampler.needs_initial_phase()`.)
        """
        return self._samplers[0].needs_initial_phase()

    def parallel(self):
        """
        Returns the number of parallel worker processes this routine will be
        run on, or ``False`` if parallelisation is disabled.
        """
        return self._n_workers if self._parallel else False

    def run(self,j,k,m,n):
        """
        Runs the MCMC sampler(s) and returns the result.

        By default, this method returns an array of shape ``(n_chains,
        n_iterations, n_parameters)``.
        If storing chains to memory has been disabled with
        :meth:`set_chain_storage`, then ``None`` is returned instead.
        """
        # Check stopping criteria
     
        has_stopping_criterion = False
        has_stopping_criterion |= (self._max_iterations is not None)
     
        if not has_stopping_criterion:
            raise ValueError('At least one stopping criterion must be set.')

        # Iteration and evaluation counting
        n_evaluations = 0

        # Choose method to evaluate
        f = self._log_pdf
        if self._needs_sensitivities:
            f = f.evaluateS1

        # Create evaluator object
        if self._parallel:
            # Use at most n_workers workers
            n_workers = min(self._n_workers, self._n_chains)
            evaluator = pints.ParallelEvaluator(f, n_workers=n_workers)
        else:
            evaluator = pints.SequentialEvaluator(f)

        # Initial phase
        if self._needs_initial_phase:
            for sampler in self._samplers:
                sampler.set_initial_phase(True)

        # Some samplers need intermediate steps, where None is returned instead
        # of a sample. Samplers can run asynchronously, so that one returns
        # None while another returns a sample.
        # To deal with this, we maintain a list of 'active' samplers that have
        # not reach `max_iterations` yet, and store the number of samples we
        # have in each chain.
        
         # Pre-allocate arrays for chain storage
       
        # Store full chains
        samples = np.zeros(
            (self._n_chains, self._max_iterations, self._n_parameters))
        if self._single_chain:
            active = list(range(self._n_chains))
            n_samples = [1] * self._n_chains
        n_proposals = [1] * self._n_chains
        n_accepted_samples = [1] * self._n_chains

        acceptedxdata0 = np.zeros((self._n_chains, self._max_iterations))
        acceptedydata0 = np.zeros((self._n_chains, self._max_iterations))
        xdata0 = np.zeros((self._n_chains, self._max_iterations))
        ydata0 = np.zeros((self._n_chains, self._max_iterations))
        #current list of proposals
        proposals = [[] for i in range(self._n_chains)]
        
        #store the starting points of chains
        for i in range(self._n_chains):
            xdata0[i][0] = self.x0[i][j]
            ydata0[i][0] = self.x0[i][k]
            acceptedxdata0[i][0] = self.x0[i][j]
            acceptedydata0[i][0] = self.x0[i][k]
        
        #set up
        plots = np.zeros((self._n_chains, 5),dtype=list)

        fig1, ax1 = plt.subplots()
        fig2, axs = plt.subplots(nrows = 1, ncols = self._n_chains*2,figsize=(10,5))
               

        #setlimits
        mins = np.amin(self.x0, axis=0)
        maxs = np.amax(self.x0, axis=0)        
        
        if self._n_chains>1:
            xRange = maxs[j] - mins[j]
            yRange = maxs[k] - mins[k]
            xlim1 = mins[j] - xRange
            xlim2 = maxs[j] + xRange
            ylim1 = mins[k] - yRange
            ylim2 = maxs[k] + yRange
        else:
            xlim1 = self.x0[0][j]*4/5
            xlim2 = self.x0[0][j]*6/5
            ylim1 = self.x0[0][k]*4/5
            ylim2 = self.x0[0][k]*6/5


        def init():
             # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
                # Calculate logpdfs
                fxs = evaluator.evaluate(xs)
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                for i in list(active):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)
            else:
                xs = self._samplers[0].ask()
                # Multi-chain methods
                 # Get all chains samples at once
                fxs = evaluator.evaluate(xs)
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                #for i in list(active):  
                    #x = xs[i]
                    #y = ys[i]

            ax1.set_xlim(xlim1, xlim2)
            ax1.set_ylim(ylim1, ylim2)
            ax1.set_xlabel('Parameter '+str(j))
            ax1.set_ylabel('Parameter '+str(k))

            
            #plots
            for c in range(self._n_chains):
                plots[c][0], = ax1.plot([], [],alpha=0.3)#b
                plots[c][1], = ax1.plot([],[],'x') #gx
                plots[c][2], = ax1.plot(xdata0[c][0], ydata0[c][0], 'o')#ro
                plots[c][3], = ax1.plot([],[],'k-',alpha=0.3)
                plots[c][4], = ax1.plot([],[],'o')#bo
                
            plist = self.flatten(plots)
            return plist
        

        def update(iteration):
            
            # Initial phase
            # Note: self._initial_phase_iterations is None when no initial
            # phase is needed
            if iteration == self._initial_phase_iterations:
                for sampler in self._samplers:
                    sampler.set_initial_phase(False)

            # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
            else:
                xs = self._samplers[0].ask()

            # Calculate logpdfs
            fxs = evaluator.evaluate(xs)

            # Update evaluation count
            #n_evaluations += len(fxs)

             # Update chains
            if self._single_chain:
                # Single chain

                # Check and update the individual chains
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                for i in list(active):  # new list: active may be modified
                    x = next(xs_iterator)
                    xdata0[i][n_proposals[i]] = x[j]
                    ydata0[i][n_proposals[i]] = x[k]
                    n_proposals[i]+=1
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)
 
                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                        proposals[i].append(x)
                        plots[i][3].set_data(acceptedxdata0[i][:n_accepted_samples[i]-1], acceptedydata0[i][:n_accepted_samples[i]-1])
                        print(acceptedxdata0[i][:n_accepted_samples[i]])  
                        plots[i][2].set_data(acceptedxdata0[i][:n_accepted_samples[i]-1], acceptedydata0[i][:n_accepted_samples[i]-1])
                        plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        plots[i][4].set_data([acceptedxdata0[i][n_accepted_samples[i]-1]],[acceptedydata0[i][n_accepted_samples[i]-1]])
            
                        accepted = np.all(y == x)
                        acceptedxdata0[i][n_accepted_samples[i]] = y[j]
                        acceptedydata0[i][n_accepted_samples[i]] = y[k]


                        
                        n_accepted_samples[i] +=1
                        if accepted:
                            proposals[i] = []
                            
                        
                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_accepted_samples[i] == self._max_iterations:
                            active.remove(i)
                            
                xdata = [[] for i in range(self._n_chains)]
                ydata = [[] for i in range(self._n_chains)]
                for i in range(self._n_chains):
                    xdata[i] = xdata0[i][0:n_proposals[i]]

                    ydata[i] = ydata0[i][0:n_proposals[i]]
                    
                import math
                xdata = np.array(self.flatten(xdata))
                ydata = np.array(self.flatten(ydata))
            
                select = math.ceil(len(xdata)*0.5)
             
                xlim1 = np.percentile(xdata[select:],5)
                xlim2 = np.percentile(xdata[select:],95)
                ylim1 = np.percentile(ydata[select:],5)
                ylim2 = np.percentile(ydata[select:],95)

                ax1.set_xlim(xlim1, xlim2)
                ax1.set_ylim(ylim1, ylim2)
                ax1.figure.canvas.draw()
                
            else:
                # Multi-chain methods
                 # Get all chains samples at once
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        proposals[i].append(x)
                    
                        plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        #plots[i][3], = ax2.hist(np.array(proposals[i])[:,j])
                        #plots[i][4], = ax3.hist(np.array(proposals[i])[:,k])

                        
                        accepted = np.all(y == x)
                        if accepted:
                            self.totalCount+=1
                            proposals[i] = []
                            acceptedxdata0[i][n_accepted_samples[i]] = y[j]
                            acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                            plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                            n_accepted_samples[i] +=1


                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_samples[i] == self._max_iterations:
                            active.remove(i)
            
            for i in range(self._n_chains):
                axs[i].clear()
                axs[i].hist([x[0] for x in proposals[i]])
                axs[self._n_chains+i].clear()
                axs[self._n_chains+i].hist([x[1] for x in proposals[i]])
            
            
            plist = self.flatten(plots)
            #print(plist)
            return plist
        
     
        ani1 = FuncAnimation(fig1, update, interval = 10, init_func = init)
        ani2 = FuncAnimation(fig2, update, interval = 10, init_func = init)
        current_date_and_time_string = datetime.now()
        #ani1.save('animation1'+str(current_date_and_time_string)+'.mp4', dpi=500)
        #ani2.save('animation2'+str(current_date_and_time_string)+'.mp4', dpi=500)
        plt.show()

    
        
        # Check stopping criteria
        
        has_stopping_criterion = False
        has_stopping_criterion |= (self._max_iterations is not None)
     
        if not has_stopping_criterion:
            raise ValueError('At least one stopping criterion must be set.')

        # Iteration and evaluation counting
        iteration = 0

        # Choose method to evaluate
        f = self._log_pdf
        if self._needs_sensitivities:
            f = f.evaluateS1

        # Create evaluator object
        if self._parallel:
            # Use at most n_workers workers
            n_workers = min(self._n_workers, self._n_chains)
            evaluator = pints.ParallelEvaluator(f, n_workers=n_workers)
        else:
            evaluator = pints.SequentialEvaluator(f)

        # Initial phase
        if self._needs_initial_phase:
            for sampler in self._samplers:
                sampler.set_initial_phase(True)

        # Some samplers need intermediate steps, where None is returned instead
        # of a sample. Samplers can run asynchronously, so that one returns
        # None while another returns a sample.
        # To deal with this, we maintain a list of 'active' samplers that have
        # not reach `max_iterations` yet, and store the number of samples we
        # have in each chain.
        
         # Pre-allocate arrays for chain storage
       
        # Store full chains
        samples = np.zeros(
            (self._n_chains, self._max_iterations, self._n_parameters))
        active = list(range(self._n_chains))
            
        n_samples = [1] * self._n_chains
        n_accepted_samples = [1] * self._n_chains
        acceptedxdata0 = np.zeros((self._n_chains, self._max_iterations))
        acceptedydata0 = np.zeros((self._n_chains, self._max_iterations))
        xdata0 = np.zeros((self._n_chains, self._max_iterations))
        ydata0 = np.zeros((self._n_chains, self._max_iterations))
        #current list of proposals
        proposals = [[] for i in range(self._n_chains)]
        
        #store the starting points of chains
        for i in range(self._n_chains):
            xdata0[i][0] = self.x0[i][j]
            ydata0[i][0] = self.x0[i][k]
            acceptedxdata0[i][0] = self.x0[i][j]
            acceptedydata0[i][0] = self.x0[i][k]
        
        #set up
        plots = np.zeros((self._n_chains, 2),dtype=list)
        fig, ax1 = plt.subplots()
        

        
        #detailed balance counts
        self.totalCount = 0
        self.directedCount = np.zeros((m,n,m,n))
        self.prob = np.zeros((m,n,m,n))
        
        running = True
        while running:
            if iteration == self._initial_phase_iterations:
                for sampler in self._samplers:
                    sampler.set_initial_phase(False)

            # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
            else:
                xs = self._samplers[0].ask()

            # Calculate logpdfs
            fxs = evaluator.evaluate(xs)
             # Update chains
            if self._single_chain:
                # Single chain

                # Check and update the individual chains
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                for i in list(active):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                        proposals[i].append(x)
            
                        accepted = np.all(y == x)
                        if accepted:
                            proposals[i] = []
                            
                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        acceptedxdata0[i][n_accepted_samples[i]] = y[j]
                        acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                        n_accepted_samples[i] +=1
                        if n_accepted_samples[i] == self._max_iterations:
                            active.remove(i)
                
            else:
                # Multi-chain methods
                 # Get all chains samples at once
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        #proposals[i].append(x)
                        
                        #plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        #plots[i][3], = ax2.hist(np.array(proposals[i])[:,j])
                        #plots[i][4], = ax3.hist(np.array(proposals[i])[:,k])

                        
                        accepted = np.all(y == x)
                        if accepted:
                            self.totalCount+=1
                            proposals[i] = []
                            acceptedxdata0[i][n_accepted_samples[i]] = y[j]
                            acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                            #plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                            n_accepted_samples[i] +=1


                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_samples[i] == self._max_iterations:
                            active.remove(i)
            iteration += 1
            # Check requested number of samples
            if (active==[]):
                running = False
                halt_message = ('Halting: Maximum number of iterations ('
                                + str(iteration) + ') reached.')
        acceptedxdata = [[] for i in range(self._n_chains)]
        acceptedydata = [[] for i in range(self._n_chains)]
        for i in range(self._n_chains):
            acceptedxdata[i] = acceptedxdata0[i][0:n_accepted_samples[i]]
            acceptedydata[i] = acceptedydata0[i][0:n_accepted_samples[i]]
        x_accepted = np.array(self.flatten(acceptedxdata))
        y_accepted = np.array(self.flatten(acceptedydata))
        import math
        select = math.ceil(len(x_accepted)*0.25)
        print(select)
             
        xlim1 = np.percentile(x_accepted[select:],5)
        print(xlim1)
        xlim2 = np.percentile(x_accepted[select:],95)
        print(xlim2)
        ylim1 = np.percentile(y_accepted[select:],5)
        ylim2 = np.percentile(y_accepted[select:],95)


        xlist = []
        ylist = []
        for i in range(m+1):
            xlist.append(xlim1+(i/n)*(xlim2-xlim1))
        for i in range(n+1):
            ylist.append(ylim1+(i/n)*(ylim2-ylim1))

        def init():
             # Get points
            ax1.set_xlim(xlim1, xlim2)
            ax1.set_ylim(ylim1, ylim2)
            ax1.set_xlabel('Parameter '+str(j))
            ax1.set_ylabel('Parameter '+str(k))
            #detailed balance grids
            for i in xlist:
                plt.axvline(i, color='green')
            for i in ylist:
                plt.axhline(i, color='green')
            
            
            #plots
            for c in range(self._n_chains):
                plots[c][0], = ax1.plot([], [],'k',alpha=0.3)
                plots[c][1], = ax1.plot(xdata0[c][0], ydata0[c][0], 'o')

            plist = self.flatten(plots)
            return plist

        def gen():
            i = 0
            while active !=[]:
                i += 1 
                yield i

        active = list(range(self._n_chains))

        def update(iteration):
            # Initial phase
            # Note: self._initial_phase_iterations is None when no initial
            # phase is needed
            activetemp = active.copy()
            for i in activetemp:
                plots[i][0].set_data([acceptedxdata[i][select+iteration-1],acceptedxdata[i][select+iteration]],[acceptedydata[i][select+iteration-1],acceptedydata[i][select+iteration]])
                #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                plots[i][1].set_data(acceptedxdata[i][0:select+iteration+1], acceptedydata[i][0:select+iteration+1])
                if iteration == len(acceptedxdata[i]) - 1:
                    active.remove(i)
                            
                        

            
            
            plist = self.flatten(plots)
            #print(plist)
            return plist    
                        
        ani = FuncAnimation(fig, update, frames = gen, interval = 10, init_func = init, blit=False)   
        plt.show()
        for iteration in range(select, len(acceptedxdata[c])):
            for u in range(m):
                if  acceptedxdata[c][iteration-1]>xlist[u] and acceptedxdata[c][iteration-1]<xlist[u+1]:
                    for v in range(n):
                        if acceptedydata[c][iteration-1]>ylist[v] and acceptedydata[c][iteration-1]<ylist[v+1]:
                            for p in range(m):
                                if acceptedxdata[c][iteration]>xlist[p] and acceptedxdata[c][iteration]<xlist[p+1]:
                                    for q in range(n):
                                        if acceptedydata[c][iteration]>ylist[q] and acceptedydata[c][iteration]<ylist[q+1]:
                                            self.directedCount[u][v][p][q]+=1
                                            break
                                    break
                            break
                    break

            for u in range(m):
                for v in range(n):
                    for p in range(m):
                        for q in range(n):
                            if self.totalCount!=0:
                                self.prob[u][v][p][q] = self.directedCount[u][v][p][q]/self.totalCount
        print(self.prob)
        
#Heatmap
    def detailedBalanceMatrix_1D_result(self,m,x0):
        assert len(x0[0])==1
        # Check stopping criteria
     
        has_stopping_criterion = False
        has_stopping_criterion |= (self._max_iterations is not None)
     
        if not has_stopping_criterion:
            raise ValueError('At least one stopping criterion must be set.')

        # Iteration and evaluation counting
        iteration = 0

        # Choose method to evaluate
        f = self._log_pdf
        if self._needs_sensitivities:
            f = f.evaluateS1

        # Create evaluator object
        if self._parallel:
            # Use at most n_workers workers
            n_workers = min(self._n_workers, self._n_chains)
            evaluator = pints.ParallelEvaluator(f, n_workers=n_workers)
        else:
            evaluator = pints.SequentialEvaluator(f)

        # Initial phase
        if self._needs_initial_phase:
            for sampler in self._samplers:
                sampler.set_initial_phase(True)

        # Some samplers need intermediate steps, where None is returned instead
        # of a sample. Samplers can run asynchronously, so that one returns
        # None while another returns a sample.
        # To deal with this, we maintain a list of 'active' samplers that have
        # not reach `max_iterations` yet, and store the number of samples we
        # have in each chain.
        
         # Pre-allocate arrays for chain storage
       
        # Store full chains
        samples = np.zeros(
            (self._n_chains, self._max_iterations, self._n_parameters))
        active = list(range(self._n_chains))
            
        n_samples = [1] * self._n_chains
        n_accepted_samples = [1] * self._n_chains
        acceptedxdata0 = np.zeros((self._n_chains, self._max_iterations))
        for i in range(self._n_chains):
            acceptedxdata0[i][0] = self.x0[i]
        
  
        self.totalCount = self._n_chains
        directedCount = np.zeros((m,m))
        prob = np.zeros((m,m))
    
        running = True    
        while running:
            # Initial phase
            # Note: self._initial_phase_iterations is None when no initial
            # phase is needed

            if iteration == self._initial_phase_iterations:
                for sampler in self._samplers:
                    sampler.set_initial_phase(False)

            # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
            else:
                xs = self._samplers[0].ask()

            # Calculate logpdfs
            fxs = evaluator.evaluate(xs)
             # Update chains
            if self._single_chain:
                # Single chain
                # Check and update the individual chains
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                activetemp = active.copy()
            
                for i in list(activetemp):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                        self.totalCount += 1
                        acceptedxdata0[i][n_accepted_samples[i]] = y[0]                            
                    
                        n_accepted_samples[i] +=1    
                            

                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_accepted_samples[i] == self._max_iterations:
                            print(n_accepted_samples[i])  
                            print(self._max_iterations)
                            active.remove(i)
                           
                
                

            else:
                # Multi-chain methods
                 # Get all chains samples at once
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        #proposals[i].append(x)
                    
                        #plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        accepted = np.all(y == x)
                        
                        self.totalCount+=1
                        #proposals[i] = []
                        acceptedxdata0[i][n_accepted_samples[i]] = y[0]
                        #acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                        #plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                        n_accepted_samples[i] +=1


                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_accepted_samples[i] == self._max_iterations:
                            active.remove(i)
                           
            iteration += 1



            # Check requested number of samples
            if (active==[]):
             
                running = False
                halt_message = ('Halting: Maximum number of iterations ('
                                + str(iteration) + ') reached.')
                print(halt_message)

        acceptedxdata = [[] for i in range(self._n_chains)]
        
        for i in range(self._n_chains):
            acceptedxdata[i] = acceptedxdata0[i][0:n_accepted_samples[i]]
        acceptedxdata = np.array(acceptedxdata)
        s = 0


        b = False
        sample_size = self._max_iterations
        '''while s < sample_size:
            chains_cut = acceptedxdata0[:,0:s+2]
            #print(chains_cut)
            rhat = pints.rhat(chains_cut)
            s+=1
            import math
            if (not math.isnan(rhat)) and (rhat< 1.05):
                print('converge')
                b = True
                break       
        print(s)'''
        acceptedxdata0 = acceptedxdata0[:,s:]
        acceptedxdata0 = [acceptedxdata0[0]]
        #x_accepted = np.array(self.flatten(acceptedxdata0)) 
        x_accepted = acceptedxdata0
        xlim1 = np.percentile(x_accepted,5)
        #print(xlim1)
        xlim2 = np.percentile(x_accepted,95)
        #print(xlim2)
      
        xlist = []

        for i in range(m+1):
            xlist.append(xlim1+(i/m)*(xlim2-xlim1))

        iteration = 1
        #active = list(range(self._n_chains))
        active = [0]
        count=0
        while (active!=[]):
            
            
            activetemp = [0] #= active.copy()
            for i in activetemp:
               
                if iteration == len(acceptedxdata0[i])-1:
                    active.remove(i)      
                for u in range(m):  
                    
                    if acceptedxdata0[i][iteration-1]>xlist[u] and acceptedxdata0[i][iteration-1]<xlist[u+1]:
                        for p in range(m):
                            if (p!=u) and acceptedxdata0[i][iteration]>xlist[p] and acceptedxdata0[i][iteration]<xlist[p+1]:
                                directedCount[u][p]+=1
                                count+=1
                                break
                        break   
            iteration += 1

        for u in range(m):
            for p in range(m):
                if count!=0:
                    prob[u][p] = directedCount[u][p]/count
        
        probRounded = np.zeros((m,m))
        for u in range(m):
            for p in range(m):
                if count!=0:
                    probRounded[u][p] = str("{:.3f}".format(prob[u][p]))
        #print(prob)
        #print(directedCount)
        s = 0
        for i in range(m):
            for j in range(m):
                s+=prob[i][j]
        #print(s)
        
        fig1, ax1 = plt.subplots(figsize=(10,5), dpi=200)
        fig2, ax2 = plt.subplots(figsize=(10,5), dpi=200)
        
        #prob_masked = np.ma.masked_where(probRounded == 0, prob)
        ax1.set_xlabel('Parameter')
        ax1.set_ylabel('Parameter')
        mask = np.zeros_like(prob, dtype=np.bool)
        mask = np.ma.masked_array(mask, mask = prob==0)
        sb.heatmap(probRounded, annot=True, ax=ax1, mask=mask)
        

       
        res = 0
        for i in range(self._n_chains):
            res+= n_accepted_samples[i]
        #print(res)
        diff = np.zeros((m,m))
        
        metric = 0
        for i in range(m):
            j = 0
            while(j<=i):
                if prob[i][j]!=0:
                    p = abs((prob[j][i] - prob[i][j])/prob[i][j])
                    
                    diff[i][j] = p*100
                    metric += p
                j+=1
        #print(diff)
        
        
        
        mask = np.zeros_like(diff, dtype=np.bool)
        mask[np.triu_indices_from(mask)] = True
        mask = np.ma.masked_array(mask, mask = prob==0)

        
        ax2.set_xlabel('Parameter')
        ax2.set_ylabel('Parameter')
        sb.heatmap(diff, mask = mask, annot = True, ax=ax2)
        
        for t in ax2.texts: 
            t.set_text(t.get_text() + " %")
        
        print('totalCount:', self.totalCount)
        fig1.savefig('fig1')
        fig2.savefig('fig2')



#return a value  
    def detailedBalanceMatrix_1D_metric(self,m,x0):
        assert len(x0[0])==1
        # Check stopping criteria
     
        has_stopping_criterion = False
        has_stopping_criterion |= (self._max_iterations is not None)
     
        if not has_stopping_criterion:
            raise ValueError('At least one stopping criterion must be set.')

        # Iteration and evaluation counting
        iteration = 0

        # Choose method to evaluate
        f = self._log_pdf
        if self._needs_sensitivities:
            f = f.evaluateS1

        # Create evaluator object
        if self._parallel:
            # Use at most n_workers workers
            n_workers = min(self._n_workers, self._n_chains)
            evaluator = pints.ParallelEvaluator(f, n_workers=n_workers)
        else:
            evaluator = pints.SequentialEvaluator(f)

        # Initial phase
        if self._needs_initial_phase:
            for sampler in self._samplers:
                sampler.set_initial_phase(True)

        # Some samplers need intermediate steps, where None is returned instead
        # of a sample. Samplers can run asynchronously, so that one returns
        # None while another returns a sample.
        # To deal with this, we maintain a list of 'active' samplers that have
        # not reach `max_iterations` yet, and store the number of samples we
        # have in each chain.
        
         # Pre-allocate arrays for chain storage
       
        # Store full chains
        samples = np.zeros(
            (self._n_chains, self._max_iterations, self._n_parameters))
        active = list(range(self._n_chains))
            
        n_samples = [1] * self._n_chains
        n_accepted_samples = [1] * self._n_chains
        acceptedxdata0 = np.zeros((self._n_chains, self._max_iterations))
        for i in range(self._n_chains):
            acceptedxdata0[i][0] = self.x0[i]
        
  
        self.totalCount = self._n_chains
        directedCount = np.zeros((m,m))
        prob = np.zeros((m,m))
    
        running = True    
        while running:
            # Initial phase
            # Note: self._initial_phase_iterations is None when no initial
            # phase is needed

            if iteration == self._initial_phase_iterations:
                for sampler in self._samplers:
                    sampler.set_initial_phase(False)

            # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
            else:
                xs = self._samplers[0].ask()

            # Calculate logpdfs
            fxs = evaluator.evaluate(xs)
             # Update chains
            if self._single_chain:
                # Single chain
                # Check and update the individual chains
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                activetemp = active.copy()
            
                for i in list(activetemp):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                        self.totalCount += 1
                        acceptedxdata0[i][n_accepted_samples[i]] = y[0]                            
                    
                        n_accepted_samples[i] +=1    
                            

                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_accepted_samples[i] == self._max_iterations:
                            print(n_accepted_samples[i])  
                            print(self._max_iterations)
                            active.remove(i)
                           
                
                

            else:
                # Multi-chain methods
                 # Get all chains samples at once
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        #proposals[i].append(x)
                    
                        #plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        accepted = np.all(y == x)
                        
                        self.totalCount+=1
                        #proposals[i] = []
                        acceptedxdata0[i][n_accepted_samples[i]] = y[0]
                        #acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                        #plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                        n_accepted_samples[i] +=1


                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_accepted_samples[i] == self._max_iterations:
                            active.remove(i)
                           
            iteration += 1



            # Check requested number of samples
            if (active==[]):
             
                running = False
                halt_message = ('Halting: Maximum number of iterations ('
                                + str(iteration) + ') reached.')
                print(halt_message)

        acceptedxdata = [[] for i in range(self._n_chains)]
        
        for i in range(self._n_chains):
            acceptedxdata[i] = acceptedxdata0[i][0:n_accepted_samples[i]]
        acceptedxdata = np.array(acceptedxdata)
        s = 0


        b = False
        sample_size = self._max_iterations
        '''while s < sample_size:
            chains_cut = acceptedxdata0[:,0:s+2]
            #print(chains_cut)
            rhat = pints.rhat(chains_cut)
            s+=1
            import math
            if (not math.isnan(rhat)) and (rhat< 1.05):
                print('converge')
                b = True
                break       
        print(s)'''
        acceptedxdata0 = acceptedxdata0[:,s:]
        acceptedxdata0 = [acceptedxdata0[0]]
        #x_accepted = np.array(self.flatten(acceptedxdata0)) 
        x_accepted = acceptedxdata0
        xlim1 = np.percentile(x_accepted,5)
        #print(xlim1)
        xlim2 = np.percentile(x_accepted,95)
        #print(xlim2)
      
        xlist = []

        for i in range(m+1):
            xlist.append(xlim1+(i/m)*(xlim2-xlim1))

        iteration = 1
        #active = list(range(self._n_chains))
        active = [0]
        count=0
        while (active!=[]):
            
            
            activetemp = [0] #= active.copy()
            for i in activetemp:
               
                if iteration == len(acceptedxdata0[i])-1:
                    active.remove(i)      
                for u in range(m):  
                    
                    if acceptedxdata0[i][iteration-1]>xlist[u] and acceptedxdata0[i][iteration-1]<xlist[u+1]:
                        for p in range(m):
                            if (p!=u) and acceptedxdata0[i][iteration]>xlist[p] and acceptedxdata0[i][iteration]<xlist[p+1]:
                                directedCount[u][p]+=1
                                count+=1
                                break
                        break   
            iteration += 1

        for u in range(m):
            for p in range(m):
                if count!=0:
                    prob[u][p] = directedCount[u][p]/count
        
        probRounded = np.zeros((m,m))
        for u in range(m):
            for p in range(m):
                if count!=0:
                    probRounded[u][p] = str("{:.3f}".format(prob[u][p]))
        #print(prob)
        #print(directedCount)
        s = 0
        for i in range(m):
            for j in range(m):
                s+=prob[i][j]
        #print(s)
        

        

       
        res = 0
        for i in range(self._n_chains):
            res+= n_accepted_samples[i]
        #print(res)
        diff = np.zeros((m,m))
        
        metric = 0
        for i in range(m):
            j = 0
            while(j<=i):
                if prob[i][j]!=0:
                    p = abs((prob[j][i] - prob[i][j])/prob[i][j])
                    
                    diff[i][j] = p*100
                    metric += p
                j+=1
        #print(diff)


        print(metric)
        return metric














        


    def detailedBalanceMatrix_1D(self,m,x0):
        assert len(x0[0])==1
        # Check stopping criteria
     
        has_stopping_criterion = False
        has_stopping_criterion |= (self._max_iterations is not None)
     
        if not has_stopping_criterion:
            raise ValueError('At least one stopping criterion must be set.')

        # Iteration and evaluation counting
        n_evaluations = 0

        # Choose method to evaluate
        f = self._log_pdf
        if self._needs_sensitivities:
            f = f.evaluateS1

        # Create evaluator object
        if self._parallel:
            # Use at most n_workers workers
            n_workers = min(self._n_workers, self._n_chains)
            evaluator = pints.ParallelEvaluator(f, n_workers=n_workers)
        else:
            evaluator = pints.SequentialEvaluator(f)

        # Initial phase
        if self._needs_initial_phase:
            for sampler in self._samplers:
                sampler.set_initial_phase(True)

        # Some samplers need intermediate steps, where None is returned instead
        # of a sample. Samplers can run asynchronously, so that one returns
        # None while another returns a sample.
        # To deal with this, we maintain a list of 'active' samplers that have
        # not reach `max_iterations` yet, and store the number of samples we
        # have in each chain.
        
         # Pre-allocate arrays for chain storage
       
        # Store full chains
        samples = np.zeros(
            (self._n_chains, self._max_iterations, self._n_parameters))
        active = list(range(self._n_chains))
            
        n_samples = [1] * self._n_chains
        n_accepted_samples = [1] * self._n_chains
        acceptedxdata0 = np.zeros((self._n_chains, self._max_iterations))
        #acceptedydata0 = np.zeros((self._n_chains, self._max_iterations))
        xdata0 = np.zeros((self._n_chains, self._max_iterations))
        #ydata0 = np.zeros((self._n_chains, self._max_iterations))
        proposals = [[] for i in range(self._n_chains)]
        for i in range(self._n_chains):
            xdata0[i][0] = self.x0[i]
            #ydata0[i][0] = self.x0[i][k]
            acceptedxdata0[i][0] = self.x0[i]
            #acceptedydata0[i][0] = self.x0[i][k]
        
        #plots = np.zeros((self._n_chains, 3),dtype=list)
        
        fig = plt.figure()
        ax1 = fig.add_subplot(2, 1, 1)
        ax2 = fig.add_subplot(2, 1, 2)
        mins = np.amin(self.x0, axis=0)
        maxs = np.amax(self.x0, axis=0)        

        if self._n_chains>1:
            xRange = maxs[0] - mins[0]
            #yRange = maxs[k] - mins[k]
            xlim1 = mins[0] - xRange
            xlim2 = maxs[0] + xRange
            #ylim1 = mins[k] - yRange??
            #ylim2 = maxs[k] + yRange
        else:
            xlim1 = self.x0[0][0]*4/5
            xlim2 = self.x0[0][0]*6/5
 
        xlist = []
        #ylist = []

        for i in range(m+1):
            xlist.append(xlim1+(i/m)*(xlim2-xlim1))
       
        self.totalCount = 0
        directedCount = np.zeros((m,m))
        prob = np.zeros((m,m))

        def init():
             # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
                # Calculate logpdfs
                fxs = evaluator.evaluate(xs)
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                for i in list(active):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)

                
            else:
                xs = self._samplers[0].ask()
                # Multi-chain methods
                 # Get all chains samples at once
                fxs = evaluator.evaluate(xs)
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]
            

            ax1.set_xlim(xlim1, xlim2)
            ax1.set_ylim(xlim1, xlim2)
            ax1.set_xlabel('Parameter 0')
            ax1.set_ylabel('Parameter 0')
            for i in xlist:
                ax1.axvline(i, color='green')
                ax1.axhline(i, color='green')
            
             
            heat_map = sb.heatmap(np.zeros((m, m)))
       
            '''texts = []
            for i in range(m):
                for j in range(m):
                    texts.append(ax1.text(xlist[i]+0.5*(1/m)*(xlim2-xlim1),xlist[j]+0.5*(1/m)*(xlim2-xlim1),'0',ha='center',va='center'))
            
            #flatten a matrix to a list
            p,= ax1.plot([xlim1,xlim2],[xlim1,xlim2],color='red')
            texts.append(p)
           
            return texts'''
            return heat_map
        p1 = []
        p2 = []
            
        def update(iteration):
            # Initial phase
            # Note: self._initial_phase_iterations is None when no initial
            # phase is needed
            if iteration == self._initial_phase_iterations:
                for sampler in self._samplers:
                    sampler.set_initial_phase(False)

            # Get points
            if self._single_chain:
                xs = [self._samplers[i].ask() for i in active]
            else:
                xs = self._samplers[0].ask()

            # Calculate logpdfs
            fxs = evaluator.evaluate(xs)
             # Update chains
            if self._single_chain:
                # Single chain

                # Check and update the individual chains
                xs_iterator = iter(xs)
                fxs_iterator = iter(fxs)
                for i in list(active):  # new list: active may be modified
                    x = next(xs_iterator)
                    fx = next(fxs_iterator)
                    y = self._samplers[i].tell(fx)

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        proposals[i].append(x)
                        #count+=1
                        #time_text.set_text(count)
                        
                        '''xmin, xmax = ax1.get_xlim()
                        ymin, ymax = ax1.get_ylim()
                        if x[j] >= xmax:
                            ax1.set_xlim(xmin, xmax+(xmax-xmin)/2)
                            ax1.figure.canvas.draw()
                        elif x[j] <= xmin:
                            ax1.set_xlim(xmin-(xmax-xmin)/2,xmax)
                            ax1.figure.canvas.draw()
                        if x[k] >= ymax:
                            ax1.set_ylim(ymin, ymax+(ymax-ymin)/2)
                            ax1.figure.canvas.draw()
                        elif x[k] <= ymin:
                            ax1.set_ylim(ymin-(ymax-ymin)/2,ymax)
                            ax1.figure.canvas.draw()'''

                        #plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        accepted = np.all(y == x)
                        if accepted:
                            self.totalCount+=1
                            proposals[i] = []
                            acceptedxdata0[i][n_accepted_samples[i]] = x[0]
                            #acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                            #plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                            
                    
                            for u in range(m):
                              
                                if acceptedxdata0[i][n_accepted_samples[i]-1]>xlist[u] and acceptedxdata0[i][n_accepted_samples[i]-1]<xlist[u+1]:
                                    for p in range(m):
                                      
                                        if x[0]>xlist[p] and x[0]<xlist[p+1]:
                                            directedCount[u][p]+=1
                                            break
                                    break
                            n_accepted_samples[i] +=1    

                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_samples[i] == self._max_iterations:
                            active.remove(i)
                
                

            else:
                # Multi-chain methods
                 # Get all chains samples at once
                ys = self._samplers[0].tell(fxs)
                # Check and update the individual chains
                
                
                for i in list(active):  # new list: active may be modified
                    x = xs[i]
                    y = ys[i]

                    if y is not None:
                        # Store sample in memory
                        if self._chains_in_memory:
                            samples[i][n_samples[i]] = y
                        else:
                            samples[i] = y
                        
                    
                        proposals[i].append(x)
                    
                        #plots[i][0].set_data([acceptedxdata0[i][n_accepted_samples[i]-1],x[j]],[acceptedydata0[i][n_accepted_samples[i]-1],x[k]])
                        #plots[i][1].set_data(np.array(proposals[i])[:,j],np.array(proposals[i])[:,k])
                        accepted = np.all(y == x)
                        if accepted:
                            self.totalCount+=1
                            proposals[i] = []
                            acceptedxdata0[i][n_accepted_samples[i]] = y[0]
                            #acceptedydata0[i][n_accepted_samples[i]] = y[k]
                            
                            #plots[i][2].set_data(acceptedxdata0[i], acceptedydata0[i])
                            n_accepted_samples[i] +=1


                        
                        # Stop adding samples if maximum number reached
                        n_samples[i] += 1
                        if n_samples[i] == self._max_iterations:
                            active.remove(i)
                           

            
            

            for u in range(m):
                for p in range(m):
                    if self.totalCount!=0:
                        prob[u][p] = directedCount[u][p]/self.totalCount
            print(p1)
            p1.append(prob[2][3])
            p2.append(prob[3][2])

            heat_map = sb.heatmap(prob)
            texts = []
            '''for i in range(m):
                for j in range(m):
                    texts.append(ax1.text(xlist[i]+0.5*(1/m)*(xlim2-xlim1),xlist[j]+0.5*(1/m)*(xlim2-xlim1),"%.3f" % (prob[i][j]),ha='center',va='center'))'''
            #p,= ax1.plot([xlim1,xlim2],[xlim1,xlim2],color='red')
            q,= ax2.plot(list(range(len(p1))),p1)
            r,= ax2.plot(list(range(len(p2))),p2)
            
            #texts.append(p)
            texts.append(heat_map)
            texts.append(q)
            texts.append(r)
            return texts
            


            
            #plist = flatten(plots)
            #plist.append(time_text)
            #print(plist)
            
            




            
        
        
        
        ani = FuncAnimation(fig, update, interval = 5, init_func = init, blit=True)
        plt.show()
        
    def sampler(self):
        """
        Returns the underlying :class:`MultiChainMCMC` object, or raises an
        error if :class:`SingleChainMCMC` objects are being used.

        See also: :meth:`samplers()`.
        """
        if self._single_chain:
            raise RuntimeError(
                'The method MCMCController.sampler() is only supported when a'
                ' MultiChainMCMC is selected. Please use'
                ' MCMCController.samplers() instead, to obtain a list of all'
                ' internal SingleChainMCMC instances.')
        return self._samplers[0]

    def samplers(self):
        """
        Returns a list containing the underlying sampler objects.

        If a :class:`SingleChainMCMC` method was selected, this will be a list
        containing as many :class:`SingleChainMCMC` objects as the number of
        chains. If a :class:`MultiChainMCMC` method was selected, this will be
        a list containing a single :class:`MultiChainMCMC` instance.
        """
        return self._samplers   
   
    def set_chain_storage(self, store_in_memory=True):
        """
        Store chains in memory as they are generated.

        By default, all generated chains are stored in memory as they are
        generated, and returned by :meth:`run()`. This method allows this
        behaviour to be disabled, which can be useful for very large chains
        which are already stored to disk (see :meth:`set_chain_filename()`).
        """
        self._chains_in_memory = bool(store_in_memory)


    def set_initial_phase_iterations(self, iterations=200):
        """
        For methods that require an initial phase (e.g. an adaptation-free
        phase for the adaptive covariance MCMC method), this sets the number of
        iterations that the initial phase will take.

        For methods that do not require an initial phase, a
        ``NotImplementedError`` is raised.
        """
        if not self._needs_initial_phase:
            raise NotImplementedError

        # Check input
        iterations = int(iterations)
        if iterations < 0:
            raise ValueError(
                'Number of initial-phase iterations cannot be negative.')
        self._initial_phase_iterations = iterations


    def set_log_interval(self, iters=20, warm_up=3):
        """
        Changes the frequency with which messages are logged.

        Parameters
        ----------
        iters : int
            A log message will be shown every ``iters`` iterations.
        warm_up : int
            A log message will be shown every iteration, for the first
            ``warm_up`` iterations.
        """
        iters = int(iters)
        if iters < 1:
            raise ValueError('Interval must be greater than zero.')
        warm_up = max(0, int(warm_up))

        self._message_interval = iters
        self._message_warm_up = warm_up

    def set_log_pdf_storage(self, store_in_memory=False):
        """
        Store :class:`LogPDF` evaluations in memory as they are generated.

        By default, evaluations of the :class:`LogPDF` are not stored. This
        method can be used to enable storage of the evaluations for the
        accepted samples.
        After running, evaluations can be obtained using :meth:`evaluations()`.
        """
        self._evaluations_in_memory = bool(store_in_memory)


    def set_log_to_file(self, filename=None, csv=False):
        """
        Enables progress logging to file when a filename is passed in, disables
        it if ``filename`` is ``False`` or ``None``.

        The argument ``csv`` can be set to ``True`` to write the file in comma
        separated value (CSV) format. By default, the file contents will be
        similar to the output on screen.
        """
        if filename:
            self._log_filename = str(filename)
            self._log_csv = True if csv else False
        else:
            self._log_filename = None
            self._log_csv = False


    def set_log_to_screen(self, enabled):
        """
        Enables or disables progress logging to screen.
        """
        self._log_to_screen = True if enabled else False


    def set_max_iterations(self, iterations=10000):
        """
        Adds a stopping criterion, allowing the routine to halt after the
        given number of `iterations`.

        This criterion is enabled by default. To disable it, use
        `set_max_iterations(None)`.
        """
        if iterations is not None:
            iterations = int(iterations)
            if iterations < 0:
                raise ValueError(
                    'Maximum number of iterations cannot be negative.')
        self._max_iterations = iterations


    def set_parallel(self, parallel=False):
        """
        Enables/disables parallel evaluation.

        If ``parallel=True``, the method will run using a number of worker
        processes equal to the detected cpu core count. The number of workers
        can be set explicitly by setting ``parallel`` to an integer greater
        than 0.
        Parallelisation can be disabled by setting ``parallel`` to ``0`` or
        ``False``.
        """
        if parallel is True:
            self._parallel = True
            self._n_workers = pints.ParallelEvaluator.cpu_count()
        elif parallel >= 1:
            self._parallel = True
            self._n_workers = int(parallel)
        else:
            self._parallel = False
            self._n_workers = 1





